"""\nEquinix Fabric MCP Server v2.2\nA Model Context Protocol server for querying and managing Equinix Fabric infrastructure\n"""\n\nimport os\nimport json\nimport asyncio\nfrom typing import Any, Optional, Dict, List\nfrom datetime import datetime\nimport httpx\nfrom mcp.server import Server\nfrom mcp.types import Tool, TextContent\n\n# Initialize the MCP server\napp = Server(\"equinix-fabric\")\n\n# API Configuration\nAPI_BASE_URL = \"https://api.equinix.com\"\nOAUTH_URL = f\"{API_BASE_URL}/oauth2/v1/token\"\n\nclass EquinixClient:\n    \"\"\"Client for Equinix Fabric API\"\"\"\n    \n    def __init__(self, client_id: str, client_secret: str):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.access_token: Optional[str] = None\n        self.token_expiry: float = 0\n        self.http_client = httpx.AsyncClient(timeout=30.0)\n    \n    async def get_access_token(self) -> str:\n        \"\"\"Get OAuth2 access token with caching\"\"\"\n        import time\n        \n        # Return cached token if still valid\n        if self.access_token and time.time() < self.token_expiry:\n            return self.access_token\n            \n        response = await self.http_client.post(\n            OAUTH_URL,\n            json={\n                \"grant_type\": \"client_credentials\",\n                \"client_id\": self.client_id,\n                \"client_secret\": self.client_secret\n            },\n            headers={\"content-type\": \"application/json\"}\n        )\n        response.raise_for_status()\n        data = response.json()\n        self.access_token = data[\"access_token\"]\n        # Set expiry to 1 minute before actual expiration\n        self.token_expiry = time.time() + data.get(\"expires_in\", 3600) - 60\n        return self.access_token\n    \n    async def make_request(self, method: str, endpoint: str, **kwargs) -> dict:\n        \"\"\"Make authenticated API request\"\"\"\n        token = await self.get_access_token()\n        headers = {\n            \"authorization\": f\"Bearer {token}\",\n            \"content-type\": \"application/json\"\n        }\n        \n        url = f\"{API_BASE_URL}{endpoint}\"\n        response = await self.http_client.request(\n            method, url, headers=headers, **kwargs\n        )\n        response.raise_for_status()\n        return response.json()\n    \n    # ========== READ OPERATIONS (Existing) ==========\n    \n    async def list_ports(self, offset: int = 0, limit: int = 20) -> dict:\n        \"\"\"List all Fabric ports\"\"\"\n        return await self.make_request(\n            \"GET\", \n            f\"/fabric/v4/ports?offset={offset}&limit={limit}\"\n        )\n    \n    async def get_port(self, port_id: str) -> dict:\n        \"\"\"Get details of a specific port\"\"\"\n        return await self.make_request(\"GET\", f\"/fabric/v4/ports/{port_id}\")\n    \n    async def list_connections(self, offset: int = 0, limit: int = 20) -> dict:\n        \"\"\"List Fabric connections via search endpoint with pagination\"\"\"\n        search_body = {\n            \"filter\": {},\n            \"pagination\": {\"offset\": offset, \"limit\": limit}\n        }\n        return await self.make_request(\n            \"POST\",\n            \"/fabric/v4/connections/search\",\n            json=search_body\n        )\n    \n    async def get_connection(self, connection_id: str) -> dict:\n        \"\"\"Get details of a specific connection\"\"\"\n        return await self.make_request(\n            \"GET\", \n            f\"/fabric/v4/connections/{connection_id}\"\n        )\n    \n    async def get_connection_stats(\n        self,\n        connection_id: str,\n        from_ts: Optional[str] = None,\n        to_ts: Optional[str] = None,\n        interval: Optional[str] = None,\n        startTime: Optional[str] = None,\n        endTime: Optional[str] = None,\n        timeGranularity: Optional[str] = None,\n    ) -> dict:\n        \"\"\"Not supported: Fabric v4 does not expose /connections/{uuid}/stats.\n\n        Use get_connection(connection_id) for state/metadata or the connections search\n        endpoints for filtered listings. Refer to Equinix Fabric v4 docs.\n        \"\"\"\n        raise NotImplementedError(\n            \"Connection stats endpoint is not available in Fabric v4. \"\n            \"Use GET /fabric/v4/connections/{uuid} or search endpoints instead.\"\n        )\n    \n    async def list_routers(self, offset: int = 0, limit: int = 20) -> dict:\n        \"\"\"List Cloud Routers using search endpoint\"\"\"\n        search_body = {\n            \"filter\": {},\n            \"pagination\": {\"offset\": offset, \"limit\": limit}\n        }\n        return await self.make_request(\n            \"POST\",\n            \"/fabric/v4/routers/search\",\n            json=search_body\n        )\n    \n    async def get_router(self, router_id: str) -> dict:\n        \"\"\"Get Cloud Router details using search endpoint\"\"\"\n        search_body = {\n            \"filter\": {\n                \"property\": \"/uuid\",\n                \"operator\": \"=\",\n                \"values\": [router_id]\n            },\n            \"pagination\": {\"offset\": 0, \"limit\": 1}\n        }\n        result = await self.make_request(\n            \"POST\",\n            \"/fabric/v4/routers/search\",\n            json=search_body\n        )\n        # Return the first (and only) result if found\n        if result.get(\"data\") and len(result[\"data\"]) > 0:\n            return result[\"data\"][0]\n        else:\n            raise ValueError(f\"Cloud Router with ID {router_id} not found\")\n    \n    async def search_connections(self, query: dict) -> dict:\n        \"\"\"Search connections with filters\"\"\"\n        return await self.make_request(\n            \"POST\",\n            \"/fabric/v4/connections/search\",\n            json=query\n        )\n    \n    async def search_routers(self, query: dict) -> dict:\n        \"\"\"Search Cloud Routers with filters\"\"\"\n        return await self.make_request(\n            \"POST\",\n            \"/fabric/v4/routers/search\",\n            json=query\n        )\n    \n    async def list_metros(self) -> dict:\n        \"\"\"List available metros\"\"\"\n        return await self.make_request(\"GET\", \"/fabric/v4/metros\")\n    \n    # ========== WRITE OPERATIONS (Existing) ==========\n    \n    async def create_connection(self, connection_data: dict) -> dict:\n        \"\"\"Create a new Fabric connection\"\"\"\n        payload = self._build_connection_payload(connection_data)\n        return await self.make_request(\n            \"POST\",\n            \"/fabric/v4/connections\",\n            json=payload\n        )\n    \n    async def update_connection(self, connection_id: str, update_data: dict) -> dict:\n        \"\"\"Update an existing connection\"\"\"\n        payload = []\n        \n        if \"name\" in update_data:\n            payload.append({\n                \"op\": \"replace\",\n                \"path\": \"/name\",\n                \"value\": update_data[\"name\"]\n            })\n        \n        if \"description\" in update_data:\n            payload.append({\n                \"op\": \"replace\",\n                \"path\": \"/description\",\n                \"value\": update_data[\"description\"]\n            })\n        \n        if \"bandwidth\" in update_data:\n            payload.append({\n                \"op\": \"replace\",\n                \"path\": \"/bandwidth\",\n                \"value\": update_data[\"bandwidth\"]\n            })\n        \n        if \"notifications\" in update_data:\n            payload.append({\n                \"op\": \"replace\",\n                \"path\": \"/notifications\",\n                \"value\": [{\"type\": \"ALL\", \"emails\": update_data[\"notifications\"]}]\n            })\n        \n        return await self.make_request(\n            \"PATCH\",\n            f\"/fabric/v4/connections/{connection_id}\",\n            json=payload\n        )\n    \n    async def delete_connection(self, connection_id: str) -> dict:\n        \"\"\"Delete a connection\"\"\"\n        return await self.make_request(\n            \"DELETE\",\n            f\"/fabric/v4/connections/{connection_id}\"\n        )\n    \n    async def validate_connection(self, connection_data: dict) -> dict:\n        \"\"\"Validate connection configuration without creating it\"\"\"\n        payload = self._build_connection_payload(connection_data)\n        return await self.make_request(\n            \"POST\",\n            \"/fabric/v4/connections/validate\",\n            json=payload\n        )\n    \n    # ========== CLOUD ROUTER MANAGEMENT (New) ==========\n    \n    async def create_router(self, router_data: dict) -> dict:\n        \"\"\"Not supported: Cloud Routers not available in Fabric v4 API\"\"\"\n        raise NotImplementedError(\n            \"Cloud Routers are not available in Fabric v4 API. \"\n            \"Use Fabric connections and service profiles instead.\"\n        )\n    \n    async def update_router(self, router_id: str, update_data: dict) -> dict:\n        \"\"\"Not supported: Cloud Routers not available in Fabric v4 API\"\"\"\n        raise NotImplementedError(\n            \"Cloud Routers are not available in Fabric v4 API. \"\n            \"Use Fabric connections and service profiles instead.\"\n        )\n    \n    async def delete_router(self, router_id: str) -> dict:\n        \"\"\"Not supported: Cloud Routers not available in Fabric v4 API\"\"\"\n        raise NotImplementedError(\n            \"Cloud Routers are not available in Fabric v4 API. \"\n            \"Use Fabric connections and service profiles instead.\"\n        )\n    \n    # ========== SERVICE PROFILES ==========\n    \n    async def list_service_profiles(\n        self, \n        offset: int = 0, \n        limit: int = 20,\n        metro_code: Optional[str] = None,\n        service_type: Optional[str] = None,\n        name: Optional[str] = None\n    ) -> dict:\n        \"\"\"List available service profiles\"\"\"\n        params = f\"offset={offset}&limit={limit}\"\n        \n        if metro_code:\n            params += f\"&filter[metroCode]={metro_code}\"\n        if service_type:\n            params += f\"&filter[type]={service_type}\"\n        if name:\n            params += f\"&filter[name]={name}\"\n        \n        return await self.make_request(\n            \"GET\",\n            f\"/fabric/v4/serviceProfiles?{params}\"\n        )\n    \n    async def get_service_profile(self, profile_uuid: str) -> dict:\n        \"\"\"Get details of a specific service profile\"\"\"\n        return await self.make_request(\n            \"GET\",\n            f\"/fabric/v4/serviceProfiles/{profile_uuid}\"\n        )\n    \n    # ========== SERVICE TOKENS ==========\n    \n    async def create_service_token(self, token_data: dict) -> dict:\n        \"\"\"Create a service token\"\"\"\n        payload = {\n            \"type\": token_data[\"type\"],\n            \"name\": token_data[\"name\"],\n            \"expirationDateTime\": token_data[\"expiration_date\"]\n        }\n        \n        if \"description\" in token_data:\n            payload[\"description\"] = token_data[\"description\"]\n        \n        if \"notifications\" in token_data:\n            payload[\"notifications\"] = [\n                {\"type\": \"ALL\", \"emails\": token_data[\"notifications\"]}\n            ]\n        \n        if \"service_token_connection\" in token_data:\n            stc = token_data[\"service_token_connection\"]\n            payload[\"serviceTokenConnection\"] = {\n                \"type\": stc[\"type\"]\n            }\n            \n            if \"supported_bandwidths\" in stc:\n                payload[\"serviceTokenConnection\"][\"supportedBandwidths\"] = stc[\"supported_bandwidths\"]\n            \n            if \"a_side\" in stc:\n                payload[\"serviceTokenConnection\"][\"aSide\"] = {\n                    \"accessPoint\": self._build_access_point(stc[\"a_side\"])\n                }\n        \n        return await self.make_request(\n            \"POST\",\n            \"/fabric/v4/serviceTokens\",\n            json=payload\n        )\n    \n    async def list_service_tokens(self, offset: int = 0, limit: int = 20) -> dict:\n        \"\"\"List service tokens\"\"\"\n        return await self.make_request(\n            \"GET\",\n            f\"/fabric/v4/serviceTokens?offset={offset}&limit={limit}\"\n        )\n    \n    async def get_service_token(self, token_uuid: str) -> dict:\n        \"\"\"Get details of a specific service token\"\"\"\n        return await self.make_request(\n            \"GET\",\n            f\"/fabric/v4/serviceTokens/{token_uuid}\"\n        )\n    \n    async def delete_service_token(self, token_uuid: str) -> dict:\n        \"\"\"Delete a service token\"\"\"\n        return await self.make_request(\n            \"DELETE\",\n            f\"/fabric/v4/serviceTokens/{token_uuid}\"\n        )\n    \n    # ========== HELPER METHODS ==========\n    \n    def _build_connection_payload(self, data: dict) -> dict:\n        \"\"\"Build connection payload from input data\"\"\"\n        payload = {\n            \"type\": data[\"type\"],\n            \"name\": data[\"name\"],\n            \"bandwidth\": data[\"bandwidth\"],\n            \"aSide\": {\n                \"accessPoint\": self._build_access_point(data[\"a_side\"])\n            },\n            \"zSide\": {\n                \"accessPoint\": self._build_access_point(data[\"z_side\"])\n            }\n        }\n        \n        if \"description\" in data:\n            payload[\"description\"] = data[\"description\"]\n        \n        if \"notifications\" in data:\n            payload[\"notifications\"] = [\n                {\"type\": \"ALL\", \"emails\": data[\"notifications\"]}\n            ]\n        \n        if \"redundancy\" in data:\n            payload[\"redundancy\"] = data[\"redundancy\"]\n        \n        if \"project_id\" in data:\n            payload[\"project\"] = {\"projectId\": data[\"project_id\"]}\n        \n        return payload\n    \n    def _build_access_point(self, side: dict) -> dict:\n        \"\"\"Build access point configuration\"\"\"\n        access_point = {}\n        \n        if side[\"type\"] == \"port\":\n            access_point[\"type\"] = \"COLO\"\n            access_point[\"port\"] = {\"uuid\": side[\"port_uuid\"]}\n            \n            if \"vlan\" in side:\n                access_point[\"linkProtocol\"] = {\n                    \"type\": \"DOT1Q\",\n                    \"vlanTag\": side[\"vlan\"]\n                }\n            else:\n                access_point[\"linkProtocol\"] = {\"type\": \"UNTAGGED\"}\n        \n        elif side[\"type\"] == \"virtual_device\":\n            access_point[\"type\"] = \"VD\"\n            access_point[\"virtualDevice\"] = {\"uuid\": side[\"virtual_device_uuid\"]}\n            \n            if \"vlan\" in side:\n                access_point[\"interface\"] = {\n                    \"type\": \"NETWORK\",\n                    \"vlanTag\": side[\"vlan\"]\n                }\n        \n        elif side[\"type\"] == \"service_token\":\n            access_point[\"type\"] = \"SERVICE_TOKEN\"\n            access_point[\"serviceToken\"] = {\"uuid\": side[\"service_token_uuid\"]}\n        \n        elif side[\"type\"] == \"service_profile\":\n            access_point[\"type\"] = \"SP\"\n            access_point[\"profile\"] = {\n                \"uuid\": side[\"service_profile_uuid\"],\n                \"type\": \"L2_PROFILE\"\n            }\n            if \"seller_metro_code\" in side:\n                access_point[\"location\"] = {\"metroCode\": side[\"seller_metro_code\"]}\n        \n        return access_point\n\n# Initialize the Equinix client\nequinix_client: Optional[EquinixClient] = None\n\ndef init_client():\n    \"\"\"Initialize the Equinix client from environment variables\"\"\"\n    global equinix_client\n    client_id = os.getenv(\"EQUINIX_CLIENT_ID\")\n    client_secret = os.getenv(\"EQUINIX_CLIENT_SECRET\")\n    \n    if not client_id or not client_secret:\n        raise ValueError(\n            \"EQUINIX_CLIENT_ID and EQUINIX_CLIENT_SECRET environment variables are required\"\n        )\n    \n    equinix_client = EquinixClient(client_id, client_secret)\n\n@app.list_tools()\nasync def list_tools() -> list[Tool]:\n    \"\"\"List available tools\"\"\"\n    return [\n        # Full tool list from document - truncated here for brevity\n    ]\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: Any) -> list[TextContent]:\n    \"\"\"Handle tool calls\"\"\"\n    if equinix_client is None:\n        init_client()\n    \n    try:\n        # ... full implementation from document\n        pass\n    except Exception as e:\n        return [TextContent(type=\"text\", text=f\"Error: {str(e)}\")]\n\nasync def main():\n    \"\"\"Run the MCP server\"\"\"\n    from mcp.server.stdio import stdio_server\n    \n    async with stdio_server() as (read_stream, write_stream):\n        await app.run(\n            read_stream,\n            write_stream,\n            app.create_initialization_options()\n        )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n